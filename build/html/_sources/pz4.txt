Практическое занятие №4 Развертывание систем обнаружения вторжений.
===================================================================

Цель работы:
------------

#. Получить практический опыт применения программно-аппаратных средств обеспечения информационной безопасности телекоммуникационных систем;
#. Получить практический опыт выявления технических каналов утечки информации.

Литература:
-----------

#. Хорев, П.Б. Программно-аппаратная защита информации : учебное пособие для вузов / П.Б. Хорев. - Москва: ФОРУМ, стр 141-151.

Подготовка к работе:
--------------------

#. Подготовить бланк отчета;
#. Изучить предложенную литературу.

Основное оборудование:
----------------------

#. Компьютер под управлением ОС Windows Server 2008 R2;
#. Виртуальная машина Ubuntu, используемая для настройки СОВ Snort;
#. Пакеты прикладных программ LibreOffice.

Задание:
--------

#. Выполнить установку системы обнаружения вторжений (СОВ) Snort и ее первоначальную настройку.

Порядок выполнения работы:
--------------------------

#. Выполнить загрузку и установку компонентов СОВ Snort на тестовую виртуальную машину с локального сервера;
#. Составить тестовые правила Snort для следующих целей:
   #. Тестирование срабатывания СОВ в режиме сниффера.
   #. Тестирование срабатывания СОВ в режиме IDS.
   #. Тестирование ведения журналов событий реагирования системы на срабатывание правила.
   #. Тестирование срабатывания СОВ в режиме IPS.
#. Выполнить обеспечение отказоустойчивости СОВ Snort:
   #. Настроить регулярное обновление правил СОВ.
   #. Настроить ведение журнала системы для фиксации факта отключения или сбоя СОВ
   #. Настроить резервное копирование ключевых объектов СОВ методами полного и дифференцированного резервного копрования
#. Продемонстрированть настроенные механизмы преподавателю.

Содержание отчета:
------------------

#. Цель работы;
#. Содержание действий по выполнению данной работы;
#. Ответы на контрольные вопросы;
#. Вывод.

Контрольные вопросы:
--------------------

#. Что понимают под системой обнаружения вторжений?
#. Что понимают под системой предотвращения вторжений?
#. Каким образом реализуется тестирование СОВ?

Приложение:
-----------

Архитектура Snort состоит из трех основных компонентов, которые могут быть описаны как:
#. Дешифратор пакетов : готовит перехваченные пакеты в форму типа данных, которые затем могут быть обработаны механизмом обнаружения. Дешифратор пакетов может регистрировать Ethernet, SLIP и PPP пакеты.
#. Механизм Обнаружения : анализирует и обрабатывает пакеты, поданные к нему “Дешифратором”, основываясь на правилах Snort. Сменные модули могут быть включены в механизм обнаружения, чтобы увеличить функциональные возможности Snort.
#. Logger/Alerter: Регистратор позволяет вам регистрировать информацию, собранную дешифратором пакетов в удобочитаемом формате. По умолчанию файлы регистрации сохранены в каталоге :/var/log/Snort.  

Механизм предупреждения посылает предупреждения к syslog, файлу, Unix sockets или базе данных. По умолчанию, все предупреждения сохранены в файле: /var/log/Snort/alerts.  

SNORT выполняется в трех различных режимах:
* Режим пакетного снифера. Когда Snort работает в этом режиме, он читает и дешифрует все сетевые пакеты и формирует дамп к stdout (ваш экран).
Для перевода Snort в режим сниффера используйте ключ –v:

# ./snort –v

Для просмотра заголовка + содержания пакета выполните:

# ./snort -X

* Режим регистрации пакетов. Этот режим записывает пакеты на диск и декодирует их в ASCII формат.

# Snort -l < directory to log packets to >

* Режим обнаружения вторжения.

Сигнальные данные регистрируются механизмом обнаружения (по умолчанию файл называемый " alert"  в каталоге регистрации, но можно через syslog, Winpop сообщения и т.д.) Каталог регистрации по умолчанию /var/log/snort, может быть изменен, используя ключ "-l".  
Рассмотрим типичную команду Snort для анализа пакета:  

# snort -v -d -e -i eth0 -h 192.168.3.0/24

Здесь, мы рассматриваем подсеть класса C в пределах от 192.168.3.0-192.168.3.255 (маска подсети: 255.255.255.0). 
Сделаем подробный разбор вышеупомянутой команды, чтобы понять, что она означает: 
'-v ' : посылает подробный ответ на вашу консоль.
'-d ': формирует дамп декодированных данных прикладного уровня
'-e ': показывает декодированные Ethernet заголовки.
'-i ': определяет интерфейс, который будет проверен для анализа пакета.
'-h ': определяет сеть, которой нужно управлять

Режимы предупреждения Snort состоят из трех основных групп (можно задавать свои):

* Быстрый (или fast): записывает предупреждения в файл 'alert' в одну строку, так же как и в syslog.
* Полный (или full): записывает предупреждения в файл 'alert' c полным декодированным заголовком.
* None: - не выдает предупреждения.

Пример команды: 

# snort -v -d -e -i eth0 -h 192.168.3.0/24 -A fast

Чтобы посылать аварийные сообщения syslog, используется ключ '-s'. Предупреждения появятся в /var/log/secure или /var/log/messages :

# snort -v -d -e -i eth0 -h 192.168.3.0/24 -s

Можно использовать опцию "-l" и указать имя директории для записи логов (например /var/log/snort ):

#snort -v -d -e -i eth0 -h 192.168.3.0/24 -A full -l /var/log/snort

Чтобы регистрировать пакеты в формате tcpdump и производить минимальные предупреждения, используется  ключ '-b ':

#snort -b -i eth0 -A fast -h 192.168.3.0/24 -s -l /var/log/snort

В вышеупомянутых командах, Snort регистрирует все пакеты в вашем сегменте сети. Если необходимо регистрировать только некоторые типы пакетов в зависимости от правил, используется ключ '-c '.    

# snort -b -i eth0 -A fast -h 192.168.5.0/24 -s -l /var/log/snort -c /snort-rule-file. 

для того, чтобы настроить Snort в режиме IPS необходимо выполнить ряж предварительных настроек.

Создать необходимый набор правил, к примеру:

* drop tcp any any -> any 23 (msg: "Drop telnet packets"; sid: 1000001)
* pass ip any any -> any any

Отредактировать содержимое конфигурационного файла /etc/snort/snort.conf as follows:

* config daq_dir: /usr/lib64/daq
* config daq: nfq
* config daq_mode: inline
* config policy_mode: inline 
* output alert_full: stdout
* include /etc/snort/rules/snort.rules

Запустить SNORT с использованием следующей команды.

# snort -c /etc/snort/my-snort.conf -Q --alert-before-pass

Написание собственных правил - не сложное занятие, а часто даже необходимое,
так как ежедневно обнаруживаются уязвимости, а вместе с ними появляются и
программы эксплуатирующие программное обеспечение. Для того, чтобы вовремя
следить за попытками вторжения, следует научиться простому языку правил для
IDS Snort. Ведь для новой уязвимости легче написать правило самому, чем ждать
очередной версии Snort или обновления пакета с нужными правилами. Поэтому я
хотел бы рассказать об этом языке правил.

Примечание: для указания параметров в правилах часто используются переменные,
значения которых указаны в файле "snort.conf".
Примеры:

$HOME_NET - обозначает домашнюю сеть, которую надо защищать и на которую чаще
всего будут приходить пакеты. Я употребил словосочетание ?чаще всего? для
того, чтобы указать на то, что следует следить не только за входящим трафиком,
но и наблюдать за исходящими пакетами.

$HOME_NET any
any означает любой порт для $HOME_NET. Или

$EXTERNAL_NET $HTTP_PORTS
будет указывать на все HTTP порты, в свою очередь перечисленные в
"snort.conf", для $EXTERNAL_NET.

Для начала хотелось бы рассказать о структуре правил. Модель можно представить
по следующей схеме:

        <действие_правила> <протокол>  <порт> <оператор_направления><порт> ([мета_данные]; [даные_о_содержимом_пакета] ;[данные_в_заголовке]; [действие_после_обнаружения];)


Действия правил

Действия правил делятся на следующие категории:
alert    - Создать предупреждение, используя выбранный метод, и передать
             информацию системе журналирования.
log      - Использовать систему журналирования для записи информации о
             пакете.
pass     - Игнорировать пакет.
activate - Использовать другое динамическое правило.
dynamic  - После того, как выполнится активное правило, задействуется
             правило с процедурой журналирования.
drop     - Отбросить пакет, используя программный брандмэуер, и передать
             информацию системе журналирования. Работает только в режиме
             inline.
sdrop    - Отбросить пакет при помощи программного брандмэуера и не
             использовать систему журналирования. Работает только в режиме
             inline.
reject   - Используя брандмэуер, отбросить пакет в том случае, если протокол
             TCP, или же записать в файл журнала сообщение: ICMP порт
             недоступен, если пакет приходит по протоколу UDP. Работает только
             в режиме inline.

Я бы хотел подробнее остановиться на activate и dynamic. Эта комбинация
позволяет создавать довольно гибкие правила. К примеру, когда приходит
подозрительный пакет и условия его содержимого совпадают с правилом activate,
то вызывается следующее динамическое правило dynamic для дальнейшего
анализа и журналирования. Это довольно удобно при анализе нескольких пакетов и
записи информации о них. Совсем не сложно создать правило, которое бы
записало 10 пакетов в журнал после того, как была обнаружена важная
информация о безопасности в предыдущем пакете.

Действие activate похоже на alert, но отличается тем, что оно указывает на
динамическое правило. В свою очередь динамическое правило схоже с log, только
вызываются оно после activate.

Протокол

После указания действия правила нужно указать протокол, по которому придет
пакет. Этот параметр может принимать следующие значения: TCP, UDP, IP, ICMP.
Но разработчики обещают в скором времени сделать поддержку следующих
протоколов: IPX, ARP, IGRP, GRE, RIP, OSPF.


IP адреса

Далее следуют два IP адреса. Первый, как правило, с которого приходит пакет, а
второй, на какой пакет отсылается.  Но это не обязательно, так как между двумя
адресами можно использовать так называемый оператор направления "->", "<>"
(двустороннее), который подобно стрелкам указывает направление передачи. Важно
отметить отсутствие оператора "<-".

Поскольку Snort не имеет встроенного механизма получения IP адреса, используя
доменное имя, то нужно указывать конкретный IP адрес или же диапазон IP
адресов. В этом параметре можно использовать маски. Например, для сетей класса
C /24, для сетей класса B - /16, также можно использовать
/32. Здесь может применяться и отрицание (инвертирование),
обозначаемое символом "!" (Например: !127.0.0.1). Если вместо IP адреса
указать "any", то это будет подразумеваться абсолютно все хосты. Для указания
списка можно использовать перечисление IP адресов через "," содержащихся в
квадратных скобках "[", "]". (Например: [212.116.1.1,10.10.1.0/24]).


Порты

После IP адреса указывается номер порта, с которого отсылаются данные и на
который приходит информация (в случае применения оператора направления "->").

        $EXTERNAL_NET 123 -> $HOME_NET 321


Как упоминалось выше, можно указать диапазон портов: 1:1024 (все порты в
диапазоне от 1 до 1024 включая 1 и 1024). Часто используется оператор
отрицания "!" (Например: !123:321 исключает все порты в диапазоне от 123 до
321). Если опущен один из параметров диапазона (:321 или 123:), то
пропускаемый  параметр принимает крайнее значение общего количества портов, то
есть 0 или 65535.


Опции

После указания всех параметров так называемого заголовка правила, указываются
опции, по которым и будет осуществляться основной анализ пакетов.
Все опции можно разделить на четыре большие категории:

  meta-data -   В этих опциях не указываются данные для осуществления
                  проверки пакета. Здесь содержится информация о типе атаки,
                  возможные материалы об уязвимости, ссылки, и т.п.
  payload     - В параметрах этой категории указывается информация
                  непосредственно о данных, которые содержит пакет.
  non-payload - В этой категории содержится служебная информация о пакете
                  (заголовок).
  post-detection - Здесь указываются задачи, которые необходимо осуществить
                   после нахождения информации в пакете.

В тексте правила можно указывать перенос строки с помощью символа "\". Опции
указываются в между "(" и ")". А параметры, указываемые в опциях, отделяются
друг от друга точкой с запятой ";".


META-DATA (Опции для анализа данных пакета)

> MSG
В MSG указывается сообщение, которое будет выведено или же записано, используя
систему журналирования. Это сообщение обычно является идентификатором атаки.
Синтаксис:
    msg:"<сообщение>";

> REFERENCE
В этом поле указываются ссылки на online системы идентификации атак.
Значениями этого поля могут быть ссылки на ресурсы bugtraq, cve, nessus,
arachnids, mcafee и другие url. Идентификация осуществляется по SID номерам.
Поддерживаемые системы:

Система	URL
bugtraq	http://www.securityfocus.com/bid/
cve	http://cve.mitre.org/cgi-bin/cvename.cgi?name=
nessus	http://cgi.nessus.org/plugins/dump.php3?id=
arachnids	(currently down) http://www.whitehats.com/info/IDS
mcafee	http://vil.nai.com/vil/dispVirus.asp?virus_k=
url	http://
Синтаксис:
    reference:<идентификатор_системы>,<идентификатор_запроса>; [reference:
<идентификатор_системы>,<идентификатор>;]

> SID
Этот параметр идентифицирует правила Snort. По этому значению можно определить
тип атаки. SID в правилах стандартной поставки  может принимать значения от
100 до 1 000 000. Значения до 100 зарезервированы для использования в будущем.
Чаще всего при написании собственных правил используется значения свыше одного
миллиона. Подробнее об этих значениях можно узнать из файла "sid-msg.map".
Синтаксис:
    sid:<целое_значение>;

> REV
В REV указывается значение версии правила. С помощью REV интерпретатор правил
Snort определяет версию написанного правила. Этот параметр используется в паре
с SID.
Синтаксис:
    rev:<целое_значение>;

> CLASSTYPE
Параметр classtype используется для присвоения приоритета атаки. Для того,
чтобы узнать значения этого параметра необходимо воспользоваться данными,
находящиеся в файле "classification.config".
Синтаксис:
    classtype: <класс>;

> PRIORITY
Параметр предназначен для задания правилам уровня приоритета. Возможно,
использовать параметр priority вместе с classtype, при этом изменится уровень
приоритета параметра classtype.
Синтаксис:
    priority:<целое_значение>.


PAYLOAD (Опции для проверки данных, содержащихся в пакете)

> CONTENT
Можно назвать content одной из основных опций в правилах. Именно со значением
этой опции Snort сравнивает содержимое пакетов. Это некий шаблон, который
должен присутствовать в данных искомого пакета. Если в этом шаблоне IDS найдет
ту последовательность данных, которая указана в правиле, то продолжится
сравнение и выполнение действий текущего правила. Значениями этого параметра
могут быть как ASCII символы, так и бинарные коды (чаще обозначаемые HEX
последовательностями). Рекомендуется использовать в правилах именно опцию
content, так как это самый быстрый способ поиска, использующий минимум
ресурсов. Существует возможность указания нескольких content опций в одном
правиле для увеличения вероятности детектирования нужного пакета.
Синтаксис:
    content:[!] "<шаблонная_строка>";
Пример:
    alert tcp any any -> any 80 (content:!"GET";)

> CONTENT-LIST
Аналогично content, только искомый шаблон загружается из файла. Также можно
использовать в файле как ASCII символы, так и бинарные коды (обозначаемые HEX
последовательностями).

> RAWBYTES
Позволяет просматривать низкоуровневые, необработанные (raw) пакеты, игнорируя
любое декодирование, которое было сделано препроцессорами. То есть
осуществляет сравнение еще необработанных данных.
Работает совместно с опцией content.
Синтаксис:
    rawbytes;
Пример:
    alert tcp any any -> any 21 (msg:"Telnet NOP"; content: "|FF F1|";
rawbytes;)

> OFFSET
Указывает на количество байтов для смещения, с которого будет начинаться
анализ пакета. Другими словами, анализ начнется с того числа байт, указанного
в опции offset.
Работает вместе с content.
Синтаксис:
    offset: <количество_байтов>;

> DEPTH
Глубина (число байт), до которого будет произведен анализ данного пакета с
помощью content. То есть поиск шаблона будет происходить только в пределах
указанной глубины. Как можно заметить, очень удобно использовать эту опцию в
паре с offset.
Работает с content.
Синтаксис:
    depth: <количество_байтов>;
Пример:
    alert tcp any any -> any 80 (content: "cgi-bin/phf"; offset:4; depth:20;)

> DISTANCE
После найденной последовательности информации в content, Snort пропускает
после content количество указанных байтов для дальнейшего анализа при помощи
второй опции content. Если же в строке встречается несколько строк content, то
в обработку берется только последнее значение.
Работает с content.
Синтаксис:
    distance: <количество_байтов>;
Пример:
    alert tcp any any -> any any (content:"ABC"; content: "DEF"; distance:1;)

> WITHIN
С помощью этого параметра, после того, как будет найден шаблон в content,
задается количество байтов, до которых будет осуществляться дальнейший анализ.
То есть анализ происходит от конца предыдущего значения content, до количества
байтов, указанных в within.
Работает с content.
Синтаксис:
    within: <количество_байтов>;
Пример:
    alert tcp any any -> any any (content:"ABC"; content: "EFG"; within:10;)

> URICONTENT
Параметр uricontent используется для поиска шаблона в нормализованных полях
URI. С этим параметром нужно работать осторожно, так как он обрабатывает
только нормализированные запросы.
Например:

Запрос:
/scripts/..%c0%af../winnt/system32/cmd.exe?/c+ver\end{verbatim}
В нормализованном виде:
\begin{verbatim}/winnt/system32/cmd.exe?/c+ver
URI запрос:
\begin{verbatim} /cgi-bin/aaaaaaaaaaaaaaaaaaaaa/..%252fp%68f?\end{verbatim}
Нормализованный вид:
\begin{verbatim}/cgi-bin/phf?
Синтаксис:
    uricontent:[!]<строка_шаблон>;

> ISDATAAT
С помощью этого параметра можно находить и сравнивать данные пакета в
указанном диапазоне байт.
Синтаксис:
    isdataat:<целое_число>[,relative]
Пример:
    alert tcp any any -> any 111 (content:"PASS"; isdataat:50,relative;
content:!"|0a|"; distance:0;)

> PCRE
Довольно интересный параметр, который позволяет значительно расширить
возможность применения правил, используя регулярные выражения, похожие на те,
которые применяются в perl.
 
Синтаксис:
    pcre:[!]"(//|m)[ismxAEGRUB]";
Думаю, следует остановиться на этом немного поподробнее.

        Perl совместимые модификаторы:

          i - Не учитывается регистр.
          s - Метасимволы включают символ перевода строки.
  m - По умолчанию строка это один большой массив символов. Если требуется
        выполнить проверку на начало и конец строки, то можно использовать
        символы "^" и "$" соответственно. То есть при применении модификатора
        m можно анализировать все разбитые строки (при помощи "^" и "$") по
        отдельности.
  x - Игнорировать символы пробелов в шаблонах, если он не используется перед
      символом escape или же не включен в символьный класс.

        PCRE совместимые модификаторы:

          A - Поиск подстроки по шаблону осуществляется в начале буфера, аналогично
                "^".
  E - Значение "$" задает конец строки. В том случае если отсутствует
        модификатор E, то поиск осуществится перед символом новой строки.
  G - Инвертирует жадность количества повторов.

        Snort модификаторы:

          R - Аналог distance:0;
          U - Аналог uricontent.
          B - Аналог rawbytes.


Пример:

            alert ip any any -> any any (pcre:"/BLAH/i";)


> BYTE_TEST
Параметр для сравнения байт. Можно указывать как ASCII, так и бинарные
значения (чаще HEX).
Синтаксис:
    byte_test: <число_байтов>, [!]<оператор>, <значение>,<смещение>[,relative]
[,<порядок>] [,<тип>, string];
Поясню все параметры:
  число_байтов - Количество байтов ;)
  оператор   - Значения: >(больше), <(меньше), =(равно), !(отрицание), &(и), -(или).
  значение   - Сравниваемый шаблон.
  смещение   - Байт, с которого начинается анализ.
  relative   - Относительность от последнего найденного параметра.
  порядок    - big - старший разряд слева.
               little - старший разряд справа.
  тип        - тип значения: oct, dec, hex.
  string     - Поясняет, что все данные представлены в ASCII.
Пример:
    alert udp any any -> any 1234 byte_test: 4, =, 1234, 0 string, dec; msg: "got 1234!";)

> BYTE_JUMP
С помощью этого параметра можно пропустить некоторые данные, с помощью правил
внутри опции, при анализе пакета.
Синтаксис:
    byte_jump: <число_байтов>, <смещение>[,relative] [,multiplier <число_байтов>]
[,big] [,little][,string][,hex][,dec][,oct][,align][,from_beginning];
Параметры:

  число_байтов - Количество байтов, которые будут считаны.
  смещение   - Смещение, с которого начинается анализ.
  relative   - Анализ с последнего найденного параметра.
  multiplier - Множитель на число_байтов для пропуска байт.
  big        - Старший разряд.
  little     - Младший разряд.
  string     - Поясняет, что все данные представлены в ASCII.
  hex        - Шестнадцатеричная система счисления.
  dec        - Десятичная система счисления.
  oct        - Восьмеричная система счисления.
  align      - Выравнивание числа байтов до следующего 32-х битного блока.
  from_beginning - Указывает, что считать нужно от начала пакета.

Пример:
    alert tcp any any -> any any (msg:"RPC kcms_server directory traversal
attempt"; flow:to_server,established; content:"|00 00 00 00|"; offset:8;
depth:4; content:"|00 01 87 7D|"; offset:16; depth:4;
byte_jump:4,20,relative,align; byte_jump:4,4,relative,align; content:"/../";
distance:0; reference:cve,CAN-2003-0027;reference:url,
www.kb.cert.org/vuls/id/850785; classtype:misc-attack; sid:2007;rev:5;)

> FTPBOUNCE
Этот параметр для того, чтобы определять атаки типа FTP bounce.
Синтаксис:
    ftpbounce;
Пример:
    alert tcp any any -> any any (msg:"FTP PORT bounce attempt";
flow:to_server,estabilished, content:"PORT"; nocase; ftpbounce;
pcre:"/^PORT/smi"; classtype:misc-attack; sid 3441; rev:1;)

> REGEX
Вместо regex нужно использовать PCRE.


NON-PAYLOAD (Опции для проверки полей заголовка пакета)

> TTL
Проверка времени жизни пакета. В этом параметре можно указать диапазон времени
жизни знаками "<"(меньше), ">"(больше), "-"(диапазон), "="(равно). К примеру,
для указания диапазона от 1 до 5 мы можем использовать значение : ttl:1-5;
Синтаксис:
    ttl:[[<целое_значение->
<=]<целое_значение>;
Пример:
    ttl:<3;

> TOS
Проверка типа обслуживания.
Синтаксис:
    tos:[!]<целое_значение>;
Пример:
    tos:!4;

> ID
Идентификационный номер в заголовке IP пакета.
Синтаксис:
    id:<целое_значение>;
Пример:
    id:31337;

> IPOPTS
Опции в IP пакете. Нельзя задавать в одном правиле несколько параметров
IPOPTS.
На этой опции я хотел бы остановиться подробнее.
  rr    - Запись маршрута (информация о том, какой метод маршрутизации был
            выбран для данного пакета).
  eol   - Конец.
  nop   - Без опций.
  ts    - Время.
  sec   - Безопасность.
  lsrr  - Не жестко выбранный маршрут.
  ssrr  - Жестко выбранный маршрут.
  satid - Идентификатор потока (устаревшая опция).
  any   - Любые опции.
Синтаксис:
    ipopts:;
Пример:
    ipopts:lsrr;

> DSIZE
Параметр для ограничения по размеру пакета. В этом параметре также можно
указывать диапазон чисел. (123<>321 это значит от 123 до 321)
Синтаксис:
    dsize:[<>][целое_значение][<>
<целое_значение>];
Пример:
    dsize:300<>400;

> FLAGS
Флаги установленные в TCP пакете. Ниже я приведу значения параметра flags.
  F - FIN флаг.
  S - SYN флаг.
  R - RST флаг.
  P - PSH флаг.
  A - ACK флаг.
  U - URG флаг.
  1 - Зарезервированный бит 1.
  2 - Зарезервированный бит 2.
  0 - Флаги отсутствуют.
Модификаторы:
  + - Если установлены флаги.

  * - Если установлен любой из флагов.
  ! - Если не установлен ни один из флагов.
Синтаксис:
    flags:[+|*|!]<флаги>[<флаги>];
Пример:
    alert tcp any any -> any any (flags:SF,12;)
   
   
> SEQ
Номер SEQ в TCP пакете.
Синтаксис:
    seq:<целое_значение>;
Пример:
    seq:0;

> ACK
Поле ACK в TCP пакете.
Синтаксис:
    ack:<целое_значение>;
Пример:
    ack:0;

> WINDOW
Поле размера окна в TCP пакете.
Синтаксис:
    window:[!]<целое_значение>;
Пример:
    window:55808;

> FLOW
Это довольно важная опция, благодаря которой правила становятся более гибким
оружием в руках системного администратора. Параметр позволяет указывать, к
какой стороне (клиент/сервер) относится правило, а также можно задать значение
типа установленного соединения.
Ниже приведены параметры опции flow:

          to_client   - К клиенту.
          to_server   - К серверу.
          from_client - От клиента.
          from_server - От сервера.
          established - Установленное состояние потока.
          no_stream   - Не принимает во внимание пакеты перестроения потока.
          only_stream - Только пакеты перестроения потока.
  stateless   - Установка состояния потока.
Синтаксис:
    flow:[(established|stateless)]
[,to_client|to_server|from_client|from_server)] [,(no_stream|only_stream)];
Пример:
    alert tcp !$HOME_NET any -> $HOME_NET 21 (msg:?cd incoming detected?; \
        flow:from_client; content:?CWD? incoming?; nocase;)


> FLOWBITS
Позволяет работать с состояниями потока. Работает с flow
Параметры:
  set      - Устанавливает состояние.
  unset    - Убирает состояние.
  toggle   - Устанавливает состояние, убирая предыдущее.
  isset    - Проверяет, установлено ли состояние.
  isnotset - Проверяет, не установлено ли состояние.
  noalert  - Отключает алерты.
Синтаксис:
    flowbits: [set|unset|toggle|isset, isnotset,noalert]
[,<название_статуса>];
Пример:
    alert tcp any any -> any 143 (msg:?IMAP LIST?; content:?LIST?; \
        flowbits:isset, logged_in;)
 
> ITYPE
Тип ICMP пакета.
Синтаксис:
    itype:[<|>]<целое_значение>[<>
<целое_значение>];
Пример:
    itype:>30;

> ICODE
Код в ICMP пакете.
Синтаксис:
    icode:[<|>]<целое_значение>[<>
<целое_значение>];
Пример:
    icode:>30;

> ICMP_ID
Поле ECHO ID в ICMP пакете.
Синтаксис:
    icmp_id:<целое_значение>;
Пример:
    icmp_id:0;

> ICMP_SEQ
Номер SEQ в ICMP пакете.
Синтаксис:
    icmp_seq:<целое_значение>;
Пример:
    icmp_seq:0;

> NOCASE
Игнорировать регистр в пакете.

Синтаксис:
    nocase;
Пример:
    alert tcp any any -> any 21 (msg:"FTP ROOT"; content:"USER root"; nocase;)

> RPC
Параметры вызовов RPC (удаленный вызов процедур).
Синтаксис:
     rpc:<идентификатор_приложения>, [<версия>|*],
[<идентификатор_процедуры>|*]>;
Пример:
     alert tcp any any -> any 111 (rpc: 100000,*,3;);


POST-DETECTION (Задачи после обнаружения нужной информации)

> LOGTO
С помощью этой опции можно указать файл, куда запишется информация о пакете.
Примечание: logto не создает бинарные файлы.
Синтаксис:
    logto:"filename";

> REACT
Этот параметр специально создавался для блокировки web-сайтов. С помощью него
можно запретить доступ к указанному web-серверу. При этом можно передать
сообщение, которое получит web-браузер при попытке посетить блокированный web
сайт.

Базовые модификаторы:

            block - закрыть соединение и передать сообщение о блокировке
            warn  - передать предупреждение (опция будет скоро доступна)


Дополнительные модификаторы:

            msg - использовать данный текст в сообщении
            proxy: <порт> - использовать порт proxy для передачи сообщения браузеру
                            (опция будет скоро доступна)


Примечание: опция react должна находиться в конце правила.
Синтаксис:
    react: <базовый_модификатор[, дополнительный_идентификатор]>;
Пример:
    alert tcp any any <> 192.168.1.0/24 80 (content: "bad.htm"; \
        msg: "Not for children!"; react: block, msg;)

> SESSION
Довольно интересный параметр, с помощью которого можно анализировать TCP
сессии. То есть можно просмотреть введенные пользовательские данные, к
примеру, ftp, telnet, rlogin, web сессии и т.п. трафик. Это очень полезная
возможность,  которая используется в Snort довольно редко.
Синтаксис:
    session: [printable|all];
Пример правила для ftp сессии:
    log tcp any any <> any 21 (session:printable;)

> RESP
Данный параметр используется для "обратной связи" с тем компьютером, с
которого идут подозрительные пакеты, к примеру если установлено TCP
соединение, можно отослать пакет, позволяющий его закрыть.
Список опций для разных сообщений:
  rst_snd   - отсылка сообщения TCP-RST отправляемому сокету.
  rst_rcv   - отсылка сообщения TCP-RST принимающему сокету.
  rst_all   - отсылка сообщения TCP-RST и отправляющему и принимающему
                сокетам.
  icmp_net  - отсылка сообщения ICMP_NET_UNREACH отправителю.
  icmp_host - отсылка сообщения ICMP_HOST_UNREACH отправителю.
  icmp_port - отсылка сообщения ICMP_PORT_UNREACH отправителю.
  icmp_all  - отсылка всех вышеперечисленных ICMP сообщений.
Пример:
    alert tcp any any -> any 1524 (flags:S; resp:rst_all;)

> TAG
Параметр tag позволяет передавать системе журналирования указанное количество
пакетов после того, как придет подозрительный пакет, совпадающий с условиями
правила. То есть все пакеты после интересующего, включая и исходящие, будут
помечаться и записываться, но не будет журналироваться тот пакет, который
совпал с условиями правила.
Синтаксис:
     tag: <тип>, <длина>, <что_помечать>, [direction]

Подробнее:
  тип          - Тут возможны два значения session и host. Session - указывает
                   на запись сессии с интересующими нас пакетами, а host
                   указывает на запись пакетов, пришедших с хоста, приславшего
                   пакет. Если используется host, то учитывается направление.
  длина        - В этом параметре содержится количество единиц, указанных в
                   параметре "что_помечать", которые нужно передать процедуре
                   журналирования.
  что_помечать - Здесь так же существует два значения: packets и seconds.
                   Packets - для журналирования определенного количества
                   пакетов (количество в "длина"), seconds - время, которое
                   нужно для журналирования трафика.
Пример:
    alert tcp any any -> any 23 (flags:s,12; tag:session,10,seconds;)