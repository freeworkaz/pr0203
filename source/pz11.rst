Практическое занятие №11 Настройка и конфигурирование межсетевых экранов в  сетях SOHO
======================================================================================

Цель работы:
------------

#. Получить практический опыт применения программно-аппаратных средств обеспечения информационной безопасности телекоммуникационных систем;
#. Получить практический опыт выявления технических каналов утечки информации.

Литература:
-----------

#. Шаньгин, В. Ф. Информационная безопасность и защита информации [Электронный ресурс]: учебное пособие. - Москва: ДМК Пресс, 2014. -  Режим доступа: http://www.iprbookshop.ru/29257, по запросу, стр 447-463;

Подготовка к работе:
--------------------

#. Подготовить бланк отчета;
#. Изучить предложенную литературу.

Основное оборудование:
----------------------

#. Межсетевой экран в составе виртуальной машины pfsense;
#. Виртуальные машины в программе VirtualBox на основе Ubuntu Linux согласно заданию и схеме сети;
#. Модель простой сети и ресурсов простой сети;
#. Пакет GNS3 и комплект виртуальных машин, необходимых для схемы сети;
#. Программа Libreoffice для составления отчетов.

Задание:
--------

#. Выполнить конфигурирование МЭ в сети small ofice home office (SOHO).

Порядок выполнения работы:
--------------------------

#. Собрать схему простой сети по индивидуальному заданию и обеспечитьл ее работоспособность.
#. Подключить pfsense в модель сети. Выполнить первичную настройку компонента (создать пользователей, сменить пароль по умолчанию, выполнить настройку).
#. Выполнить фильтрацию трафика. Настроить межсетевой экран по «белому» списку для обеспечения разрешенных подключений от клиентов к серверам. Все подключения, кроме разрешенных, должны блокироваться с ведением записей в журнал.
#. Выполнить фильтрацию трафика. Настроить межсетевой экран по «черному» списку для обеспечения запрета подключений от клиентов к серверам.Все подключения, кроме запрещенных, должны разрешаться с ведением записей в журнал.
#. Выполнить создание пользователей pfsense, отличных от администратора.
#. Выполнить создание сертификата пользователя и организовать доступ к настройкам pfsense только для пользователя, имеющего сертификат.
#. Выполнить настройку ведения журналов подключения пользователей pfsense.
#. Выполнить настройку средств отказоустойчивости МЭ pfsense.
#. Выполить настройку полного резервного копирования настроек МЭ.
#. Выполить настройку дифференцированного резервного копирования настроек МЭ.
#. Составить план проведения резервного копирования настроек МЭ

Содержание отчета:
------------------

#. Цель работы;
#. Содержание действий по выполнению данной работы;
#. Ответы на контрольные вопросы;
#. Вывод.

Контрольные вопросы:
--------------------

#. Каким образом достигается дифференцированное резервное копирование?
#. Что понимают под «черным списком» межсетевого экрана?
#. Для каких целей ведется настройка системных журналов МЭ?

Приложение:
-----------

Предположим, что у нашего сервера есть два физических сетевых интерфейса: eth0 (открытый) и eth1 (закрытый). Необходимо соединить их с помощью NAT (network address transform – преобразование сетевых адресов), чтобы сетевой трафик мог прозрачно передаваться из одного интерфейса в другой. В качестве маски подсети закрытой сети используется 192.168.0.0/255.255.0.0; в листинге 12 приведено NAT-правило для перенаправления.

Правила для NAT и перенаправления:
::

   iptables -A FORWARD -s 192.168.0.0/255.255.0.0 -i eth0 -o eth1 -m\
   conntrack --ctstate NEW -j ACCEPT
   iptables -A FORWARD -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
   iptables -A POSTROUTING -t nat -j MASQUERADE

Далее необходимо модифицировать настройки в proc, чтобы активировать перенаправление на сервере.
Активация перенаправления на сервере
::

   sh -c "echo 1 > /proc/sys/net/ipv4/ip_forward"

Стоит отметить, что изменения в proc не сохраняются, так что они будут утрачены после перезагрузки. Есть несколько способов обеспечить сохранность изменений после перезагрузки. Чтобы обеспечить запуск указанных строк в дистрибутивах Debian/Ubuntu, необходимо добавить их в /etc/rc.local.

Далее показано еще одно изменение в конфигурации, меняющее параметры ядра во время выполнения (sysctl). Эти параметры конфигурации обычно находятся в файле sysctl.conf, но они закомментированы. Необходимо их раскомментировать или добавить в файл, если они отсутствуют в используемом дистрибутиве.
Настройка параметра ядра - sysctl
::

   net.ipv4.conf.default.forwarding=1
   net.ipv4.conf.all.forwarding=1

Пороговое значение кэша ARP
```````````````````````````

Использование Linux-сервера в качестве шлюза вызывает определенные проблемы, связанные с DNS. Ядро спроектировано так, чтобы хранить привязку IP-адресов, но заданное максимальное количество записей недостаточно для поддержки большого количества трафика. Когда достигается максимальный уровень, сервер перестает отвечать на DNS-запросы от клиентов. При небольшом количестве клиентов этот порог достигается редко, но более тридцати клиентов, одновременно использующих данный межсетевой экран, могут привести к проблемам.

Значения, приведенные далее, обычно вполне достаточны для исключения подобных проблем, хотя для вашей среды могут потребоваться изменения.
Увеличение размера кэша ARP
::
   echo 1024 > /proc/sys/net/ipv4/neigh/default/gc_thresh1
   echo 2048 > /proc/sys/net/ipv4/neigh/default/gc_thresh2
   echo 4096 > /proc/sys/net/ipv4/neigh/default/gc_thresh3

Указанием на то, что пришло время увеличить указанные значения, служит появление в системном журнале предупреждающих сообщений, подобных приведенным ниже.
Предупреждающие сообщения о переполнении кэша ARP
::
   Nov  22 11:36:16 firewall kernel: [92374.325689] Neighbour table overflow.
   Nov  22 11:36:20 firewall kernel: [92379.089870] printk: 37 messages suppressed.
   Nov  22 11:36:20 firewall kernel: [92379.089876] Neighbour table overflow.
   Nov  22 11:36:26 firewall kernel: [92384.333161] printk: 51 messages suppressed.
   Nov  22 11:36:26 firewall kernel: [92384.333166] Neighbour table overflow.
   Nov  22 11:36:30 firewall kernel: [92389.084373] printk: 200 messages suppressed.
   
Настроив МЭ таким образом можно переходить к настройке правил межсетевого экрана.

аправление соединения, бывает входящее и исходящее. Исходящим называется соединение, инициируемое локальным компьютером, входящим — инициируемое удаленным компьютером. Обратите внимание, что, если ваш браузер обращается к некоторому ресурсу в сети, и тот отвечает ему какими-либо данными, то этот ответ по-прежнему считается отправленным в рамках исходящего подключения.

Суть работы брандмауэра заключается в разрешении одних соединений (подключений) и блокировании других. В связи с этим, следуя правилам фильтрации появились понятия:

   * Черный список: разрешить все, кроме запрещенного.
   * Белый список: запретить все кроме разрешенного.

Настройка МЭ по белому списку
`````````````````````````````

Если у вас свежеустановленная система и вы не пытались настроить на ней сетевой фильтр, то правила будут иметь примерно следующую картину:
::

   netfilter:~# iptables -L
   Chain INPUT (policy ACCEPT)
   target prot opt source destination
   Chain FORWARD (policy ACCEPT)
   target prot opt source destination
   Chain OUTPUT (policy ACCEPT)
   target prot opt source destination

Это значит, что политика по умолчанию для таблицы filter во всех цепочках - ACCEPT и нет никаких других правил, что-либо запрещающих. Поэтому давайте сначала запретим ВСЁ входящие, исходящие и проходящие пакеты (не вздумайте это делать удаленно-тут же потеряете доступ):
::

   netfilter:~# iptables -P INPUT DROP
   netfilter:~# iptables -P OUTPUT DROP
   netfilter:~# iptables -P FORWARD DROP

Этими командами мы устанавливаем политику DROP по умолчанию. Это значит, что любой пакет, для которого явно не задано правило, которое его разрешает, автоматически отбрасывается. Поскольку пока еще у нас не задано ни одно правило - будут отвергнуты все пакеты, которые придут на ваш компьютер, равно как и те, которые вы попытаетесь отправить в сеть. В качестве демонстрации можно попробовать пропинговать свой компьютер через интерфейс обратной петли:
::

   netfilter:~# ping -c2 127.0.0.1
   PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
   ping: sendmsg: Operation not permitted
   ping: sendmsg: Operation not permitted
   --- localhost ping statistics ---
   2 packets transmitted, 0 received, 100% packet loss, time 1004ms

На самом деле это полностью не функционирующая сеть и это не очень хорошо, т.к. некоторые демоны используют для обмена между собой петлевой интерфейс, который после проделанных действий более не функционирует. Это может нарушить работу подобных сервисов. Поэтому в первую очередь в обязательно разрешим передачу пакетов через входящий петлевой интерфейс и исходящий петлевой интерфейс в таблицах INPUT (для возможности получения отправленных пакетов) и OUTPUT (для возможности отправки пакетов) соответственно. Итак, обязательно выполняем:
::

   netfilter:~# iptables -A INPUT -i lo -j ACCEPT 
   netfilter:~# iptables -A OUTPUT -o lo -j ACCEPT

После этого пинг на локалхост заработает:
::

   netfilter:~# ping -c1 127.0.0.1
   PING 127.0.0.1 (127.0.0.1) 56(84) bytes of data.
   64 bytes from 127.0.0.1 (127.0.0.1): icmp_seq=1 ttl=64 time=0.116 ms
   --- 127.0.0.1 ping statistics ---
   1 packets transmitted, 1 received, 0% packet loss, time 116ms
   rtt min/avg/max/mdev = 0.116/0.116/0.116/0.116 ms

Если подходить к настройке файервола не шибко фанатично, то можно разрешить работу протокола ICMP:
::

   netfilter:~# iptables -A INPUT -p icmp -j ACCEPT
   netfilter:~# iptables -A OUTPUT -p icmp -j ACCEPT

Более безопасно будет указать следующую аналогичную команду iptables:
::

   netfilter:~# iptables -A INPUT -p icmp --icmp-type 0 -j ACCEPT
   netfilter:~# iptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT
   netfilter:~# iptables -A OUTPUT -p icmp -j ACCEPT

Данная команда разрешит типы ICMP пакета эхо-запрос и эхо-ответ, что повысит безопасность.

Будем считать, что компьютер не заражен вредоносным ПО и он устанавливает только безопасные исходящие соединения. А так же, зная, что безопасные соединения - это соединения из т.н. эфимерного диапазона портов, который задается ядром в файле /proc/sys/net/ipv4/ip_local_port_range, можно разрешить исходящие соединения с этих безопасных портов:
::

   netfilter:~# cat /proc/sys/net/ipv4/ip_local_port_range
   32768 61000
   netfilter:~# iptables -A OUTPUT -p TCP --sport 32768:61000 -j ACCEPT
   netfilter:~# iptables -A OUTPUT -p UDP --sport 32768:61000 -j ACCEPT

Если подходить к ограничению исходящих пакетов не параноидально, то можно было ограничиться одной командой iptables, разрешающей все исхолящие соединения оп всем протоколам и портам:
::

   netfilter:~# iptables -A OUTPUT -j ACCEPT
   netfilter:~# # или просто задать политику по умолчанию ACCEPT для цепочки OUTPUT
   netfilter:~# iptables -P OUTPUT ACCEPT

Далее, зная что в netfilter сетевые соединения имеют 4 состояния (NEW, ESTABLISHED, RELATED и INVALID) и новые исходящие соединения с локального компьютера (с состоянием NEW) у нас разрешены в прошлых двух командах iptables, что уже установленные соединения и дополнительные имеют состояния ESTABLISHED и RELATED, соответственно, а так же зная, что входящие соединения к локальной системе приходят через цепочку INPUT, можно разрешить попадание на наш компьютер только тех TCP- и UDP-пакетов, которые были запрошены локальными приложениями:
::

   netfilter:~# iptables -A INPUT -p TCP -m state --state ESTABLISHED,RELATED -j ACCEPT
   netfilter:~# iptables -A INPUT -p UDP -m state --state ESTABLISHED,RELATED -j ACCEPT

Если на десктопе все же работает какая-то сетевая служба, то необходимо добавить соответствующие правила для входящих соединений и для исходящих. Например, для работы ssh-сервера, который принимает и отправляет запросы на 22 TCP-порту, необходимо добавить следующие iptables-правила:
::

   netfilter:~# iptables -A INPUT -i eth0 -p TCP --dport 22 -j ACCEPT 
   netfilter:~# iptables -A OUTPUT -o eth0 -p TCP --sport 22 -j ACCEPT

Т.е. для любого сервиса нужно добавить по одному правилу в цепочки INPUT и OUTPUT, разрешающему соответственно прием и отправку пакетов с использованием этого порта для конкретного сетевого интерфейса (если интерфейс не указывать, то будет разрешено принимать/отправлять пакеты по любому интерфейсу).

Настройка netfilter/iptables для подключения нескольких клиентов к одному соединению.
`````````````````````````````````````````````````````````````````````````````````````

Рассмотрим использование Linux в качестве шлюза для локальной сети во внешнюю сеть Internet. Предположим, что интерфейс eth0 подключен к интернету и имеет IP 198.166.0.200, а интерфейс eth1 подключен к локальной сети и имеет IP 10.0.0.1. По умолчанию, в ядре Linux пересылка пакетов через цепочку FORWARD (пакетов, не предназначенных локальной системе) отключена. Чтобы включить данную функцию, необходимо задать значение 1 в файле /proc/sys/net/ipv4/ip_forward:
::

   netfilter:~# echo 1 > /proc/sys/net/ipv4/ip_forward

Чтобы форвардинг пакетов сохранился после перезагрузки, необходимо в файле /etc/sysctl.conf раскомментировать (или просто добавить) строку net.ipv4.ip_forward=1.

Итак, у нас есть внешний адрес (198.166.0.200), в локальной сети имеется некоторое количество гипотетических клиентов, которые имеют адреса из диапазона локальной сети и посылают запросы во внешнюю сеть. Если эти клиенты будут отправлять во внешнюю сеть запросы через шлюз "как есть", без преобразования, то удаленный сервер не сможет на них ответить, т.к. обратным адресом будет получатель из "локальной сети". Для того, чтобы эта схема корректно работала, необходимо подменять адрес отправителя, на внешний адрес шлюза Linux. Это достигается за счет действия MASQUERADE (маскарадинг) в цепочке POSTROUTING, в таблице nat.
::

   netfilter:~# iptables -A FORWARD -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
   netfilter:~# iptables -A FORWARD -m conntrack --ctstate NEW -i eth1 -s 10.0.0.1/24 -j ACCEPT
   netfilter:~# iptables -P FORWARD DROP
   netfilter:~# iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE

Итак, по порядку сверху-вниз мы разрешаем уже установленные соединения в цепочке FORWARD, таблице filter, далее мы разрешаем устанавливать новые соединения в цепочке FORWARD, таблице filter, которые пришли с интерфейса eth1 и из сети 10.0.0.1/24. Все остальные пакеты, которые проходят через цепочку FORWARD - отбрасывать. Далее, выполняем маскирование (подмену адреса отправителя пакета в заголовках) всех пакетов, исходящих с интерфейса eth0.
Кроме указанных правил так же нужно добавить правила для фильтрации пакетов, предназначенных локальному хосту - как описано в прошлом разделе. То есть добавить запрещающие и разрешающие правила для входящих и исходящих соединений:
::

   netfilter:~# iptables -P INPUT DROP
   netfilter:~# iptables -P OUTPUT DROP
   netfilter:~# iptables -A INPUT -i lo -j ACCEPT 
   netfilter:~# iptables -A OUTPUT -o lo -j ACCEPT
   netfilter:~# iptables -A INPUT -p icmp --icmp-type 0 -j ACCEPT
   netfilter:~# iptables -A INPUT -p icmp --icmp-type 8 -j ACCEPT
   netfilter:~# iptables -A OUTPUT -p icmp -j ACCEPT
   netfilter:~# cat /proc/sys/net/ipv4/ip_local_port_range
   32768 61000
   netfilter:~# iptables -A OUTPUT -p TCP --sport 32768:61000 -j ACCEPT
   netfilter:~# iptables -A OUTPUT -p UDP --sport 32768:61000 -j ACCEPT
   netfilter:~# iptables -A INPUT -p TCP -m state --state ESTABLISHED,RELATED -j ACCEPT
   netfilter:~# iptables -A INPUT -p UDP -m state --state ESTABLISHED,RELATED -j ACCEPT

В результате, если один из хостов локальной сети, например 10.0.0.2, попытается связаться с одним из интернет-хостов, например, 93.158.134.3 (ya.ru), при проходе его пакетов через шлюз, их исходный адрес будет подменяться на внешний адрес шлюза в цепочке POSTROUTING таблице nat, то есть исходящий IP  10.0.0.2 будет заменен на 198.166.0.200. С точки зрения удаленного хоста (ya.ru), это будет выглядеть, как будто с ним связывается непосредственно сам шлюз. Когда же удаленный хост начнет ответную передачу данных, он будет адресовать их именно шлюзу, то есть 198.166.0.200. Однако, на шлюзе адрес назначения этих пакетов будет подменяться на 10.0.0.2, после чего пакеты будут передаваться настоящему получателю в локальной сети. Для такого обратного преобразования никаких дополнительных правил указывать не нужно — это будет делать все та же операция MASQUERADE, которая помнит какой хост из локальной сети отправил запрос и какому хосту необходимо вернуть пришедший ответ.

Примечание: желательно негласно принято, перед всеми командами iptables очищать цепочки, в которые будут добавляться правила:
::

   netfilter:~# iptables -F ИМЯ_ЦЕПОЧКИ